"""
Label writer module for generating YOLOv8-Seg format labels.
"""

import logging
from pathlib import Path
from typing import List, Tuple

from .ingest import Polygon

logger = logging.getLogger("engine.label_writer")


class LabelWriter:
    """Writes polygon annotations in YOLOv8-Seg format."""
    
    def __init__(self, output_dir: Path):
        """
        Initialize label writer.
        
        Args:
            output_dir: Base output directory
        """
        self.output_dir = Path(output_dir)
    
    def write(
        self,
        polygons: List[Polygon],
        output_path: Path
    ) -> None:
        """
        Write polygons to a label file.
        
        Args:
            polygons: List of polygon annotations
            output_path: Path to output label file
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        lines = []
        for polygon in polygons:
            if not self._validate_polygon(polygon):
                logger.warning(f"Skipping invalid polygon: {polygon}")
                continue
            
            line = self._polygon_to_line(polygon)
            lines.append(line)
        
        with open(output_path, "w") as f:
            f.write("\n".join(lines))
        
        logger.debug(f"Wrote {len(lines)} polygons to {output_path}")
    
    def _polygon_to_line(self, polygon: Polygon) -> str:
        """
        Convert polygon to YOLOv8-Seg format line.
        
        Format: <class_id> x1 y1 x2 y2 ... xn yn
        """
        coords = []
        for x, y in polygon.points:
            x = max(0.0, min(1.0, x))
            y = max(0.0, min(1.0, y))
            coords.extend([f"{x:.6f}", f"{y:.6f}"])
        
        return f"{polygon.class_id} " + " ".join(coords)
    
    def _validate_polygon(self, polygon: Polygon) -> bool:
        """
        Validate a polygon.
        
        Returns:
            True if polygon is valid, False otherwise
        """
        if len(polygon.points) < 3:
            return False
        
        for x, y in polygon.points:
            if not (0 <= x <= 1 and 0 <= y <= 1):
                return False
        
        area = self._compute_polygon_area(polygon.points)
        if area < 0.0001:
            return False
        
        return True
    
    def _compute_polygon_area(
        self,
        points: List[Tuple[float, float]]
    ) -> float:
        """Compute polygon area using shoelace formula."""
        n = len(points)
        if n < 3:
            return 0.0
        
        area = 0.0
        for i in range(n):
            j = (i + 1) % n
            area += points[i][0] * points[j][1]
            area -= points[j][0] * points[i][1]
        
        return abs(area) / 2.0
    
    def write_batch(
        self,
        batch: List[Tuple[List[Polygon], Path]]
    ) -> int:
        """
        Write multiple label files.
        
        Args:
            batch: List of (polygons, output_path) tuples
            
        Returns:
            Number of files written
        """
        count = 0
        for polygons, output_path in batch:
            try:
                self.write(polygons, output_path)
                count += 1
            except Exception as e:
                logger.error(f"Failed to write {output_path}: {e}")
        
        return count


def create_dataset_yaml(
    output_dir: Path,
    train_dir: str = "train",
    val_dir: str = "val",
    class_names: List[str] = None
) -> Path:
    """
    Create dataset YAML file for YOLO training.
    
    Args:
        output_dir: Output directory containing train/val folders
        train_dir: Name of training directory
        val_dir: Name of validation directory
        class_names: List of class names
        
    Returns:
        Path to created YAML file
    """
    if class_names is None:
        class_names = ["text"]
    
    output_dir = Path(output_dir)
    yaml_path = output_dir / "dataset.yaml"
    
    yaml_content = f"""# YOLOv8 Segmentation Dataset
# Auto-generated by Text Detection Dataset Generator

path: {output_dir.absolute()}
train: {train_dir}/images
val: {val_dir}/images

# Classes
names:
"""
    
    for i, name in enumerate(class_names):
        yaml_content += f"  {i}: {name}\n"
    
    with open(yaml_path, "w") as f:
        f.write(yaml_content)
    
    logger.info(f"Created dataset YAML: {yaml_path}")
    
    return yaml_path
